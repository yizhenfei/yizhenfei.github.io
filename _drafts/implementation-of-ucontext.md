---
layout: post
title: "ucontext 实现原理"
date: 2017-09-10 13:56:00 +0800
categories: infra
---
## 起因
大约4年前，我在腾讯参与开发一个叫作 matrix 的分布式系统平台。其中的一个模块，就是利用 C 标准库 ucontext.h 头文件中提供的一系列上下文切换 (context switching) 函数，在 C++ 中实现协程 (coroutine)。目的是让应用层能够使用同步的写法，获得（近似）异步的性能。这两年来，类似的 C 协程库层出不穷，得到了广泛的应用，但是他们的技术原理基本没有变化，依然是使用 ucontext 系列函数。

基于这几年在服务端开发过程中的思考，我在筹划编写一门新的语言。“同步写法，异步性能”依然是她非常重要的一个特点，只不过不会用协程的形式来提供，而是会采用类似 Erlang 的用户态进程 (user process) 形式。另外，这门语言会使用 LLVM 编译成原生 (native) 目标执行，而不是基于虚拟机。因此依然需要使用到上下文切换功能。

经过一番搜索以后，发现有人曾经提议过在 LLVM 中加入上下文切换相关的原语 (instrinsic) [[1]]，但是从最新的文档来看，这个功能最终并没有能够进入 LLVM。因此新语言的运行时 (runtime) 依然需要通过 ucontext 来实现上下文切换。所以我必须研究一下 ucontext 的实现细节，才可以判断它与 LLVM 生成的代码互相操作时是否能够保持兼容。

## 上下文包含的数据内容
ucontext 系列函数操作的核心数据结构是 ucontext_t，他包含了一个上下文的所有数据。由此我们可以进行上下文的保存和换入工作。

在 glibc 2.26 的实现中，并没有直接定义这个数据结构，而是通过操作系统提供的 sys/ucontext.h

[1]: http://lists.llvm.org/pipermail/llvm-dev/2010-April/030792.html
